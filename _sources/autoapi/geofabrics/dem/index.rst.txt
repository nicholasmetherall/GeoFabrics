:py:mod:`geofabrics.dem`
========================

.. py:module:: geofabrics.dem

.. autoapi-nested-parse::

   This module contains classes associated with loading, generating, and combining
   DEMs.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   geofabrics.dem.CoarseDem
   geofabrics.dem.DemBase
   geofabrics.dem.HydrologicallyConditionedDem
   geofabrics.dem.LidarBase
   geofabrics.dem.RawDem
   geofabrics.dem.RoughnessDem



Functions
~~~~~~~~~

.. autoapisummary::

   geofabrics.dem.read_file_with_pdal
   geofabrics.dem.roughness_from_points
   geofabrics.dem.elevation_from_points
   geofabrics.dem.calculate_idw
   geofabrics.dem.calculate_linear
   geofabrics.dem.load_tiles_in_chunk
   geofabrics.dem.roughness_over_chunk
   geofabrics.dem.elevation_over_chunk



Attributes
~~~~~~~~~~

.. autoapisummary::

   geofabrics.dem.delayed_roughness_over_chunk
   geofabrics.dem.delayed_elevation_over_chunk


.. py:class:: CoarseDem(dem_file, catchment_geometry, set_foreshore = True, exclusion_extent = None)

   A class to manage coarse or background DEMs in the catchment context

   Specifically, clip within the catchment land and foreshore. There is the option to
   clip outside any LiDAR using the
   optional 'exclusion_extent' input.

   If set_foreshore is True all positive DEM values in the foreshore are set to zero.

   .. py:property:: dem
      :type: xarray.Dataset

      Return the DEM over the catchment region

   .. py:property:: resolution
      :type: float

      Return the largest dimension of the coarse DEM resolution

   .. py:property:: points
      :type: numpy.ndarray

      The coarse DEM points after any extent or foreshore value
      filtering.

   .. py:property:: extents
      :type: geopandas.GeoDataFrame

      The extents for the coarse DEM

   .. py:method:: __del__()

      Ensure the memory associated with netCDF files is properly freed.



.. py:class:: DemBase(catchment_geometry, extents)

   Bases: :py:obj:`abc.ABC`

   An abstract class to manage the dense DEM in a catchment context.

   The dense DEM is made up of a dense DEM that is loaded in, and an offshore DEM that
   is interpolated from bathymetry contours offshore and outside all LiDAR tiles.

   :param catchment_geometry: Defines the spatial extents of the catchment, land, foreshore, and offshore
                              regions
   :param extents: Defines the extents of any dense (LiDAR or refernence DEM) values already added.

   .. py:property:: extents

      The combined extents for all added LiDAR tiles

   .. py:property:: dem
      :type: xarray.Dataset
      :abstractmethod:

      Return the DEM over the catchment region


.. py:class:: HydrologicallyConditionedDem(catchment_geometry, raw_dem_path, extents_path, interpolation_method)

   Bases: :py:obj:`DemBase`

   A class to manage loading in an already created and saved dense DEM that has yet
   to have an offshore DEM associated with it.

   :param Logic controlling behaviour:
                                       interpolation_method
                                           If not None, interpolate using that method. Valid options are 'linear',
                                           'nearest', and 'cubic'

   .. py:property:: dem

      Return the combined DEM from tiles and any interpolated offshore values

   .. py:method:: __del__()

      Ensure the memory associated with netCDF files is properly freed.


   .. py:method:: combine_dem_parts()

      Return the combined DEM from all layers that exist.


   .. py:method:: interpolate_bathymetry_points(bathymetry_points, flat_x_array, flat_y_array, method)

      Interpolate the bathymetry points at the specified locations using the
      specified method.


   .. py:method:: interpolate_ocean_bathymetry(bathy_contours)

      Performs interpolation offshore outside LiDAR extents using the SciPy RBF
      function.


   .. py:method:: interpolate_river_bathymetry(estimated_bathymetry)

      Performs interpolation over drains, culverts, rivers and river fan
      polygons using various interpolation techniques.



.. py:class:: LidarBase(catchment_geometry, elevation_range = None)

   Bases: :py:obj:`DemBase`

   A class with some base methods for reading in LiDAR data.

   :param catchment_geometry: Defines the geometry of the catchment
   :param elevation_range: The range of valid LiDAR elevations. i.e. define elevation filtering to apply.

   .. py:property:: dem

      Return the combined DEM from tiles and any interpolated offshore values

   .. py:method:: __del__()

      Ensure the memory associated with netCDF files is properly freed.


   .. py:method:: add_lidar(lidar_files, tile_index_file, chunk_size, lidar_classifications_to_keep, source_crs, metadata)
      :abstractmethod:

      Read in all LiDAR files and use to create a dense DEM.

      :param source_crs: Coordinate reference system information
      :param chunk_size: The chunk size in pixels for parallel/staged processing
      :param lidar_files: The list of LiDAR files to read in
      :param tile_index_file: A file specifying the spatial extents of the LiDAR files.
      :param lidar_classifications_to_keep: A list of LiDAR classifications to keep - '2' for ground, '9' for water.
                                            See https://www.asprs.org/wp-content/uploads/2010/12/LAS_1_4_r13.pdf for
                                            standard list
      :param meta_data: Information to include in the created DEM.



.. py:class:: RawDem(catchment_geometry, lidar_interpolation_method, drop_offshore_lidar = True, elevation_range = None)

   Bases: :py:obj:`LidarBase`

   A class to manage the creation of a 'raw' DEM from LiDAR tiles, and/or a
   coarse DEM.

   :param drop_offshore_lidar: If True only keep LiDAR values within the foreshore and land regions defined by
                               the catchment_geometry. If False keep all LiDAR values.
   :param elevation_range: Optitionally specify a range of valid elevations. Any LiDAR points with
                           elevations outside this range will be filtered out.
   :param lidar_interpolation_method: The interpolation method to apply to LiDAR during downsampling/averaging.
                                      Options are: mean, median, IDW, max, min, STD.

   .. py:method:: add_lidar(lidar_files, tile_index_file, chunk_size, lidar_classifications_to_keep, source_crs, metadata)

      Read in all LiDAR files and use to define a 'raw' DEM with elevations in
      pixels where there is LiDAR or coarse DEM information.

      :param source_crs: Coordinate reference system information
      :param chunk_size: The chunk size in pixels for parallel/staged processing
      :param lidar_files: The list of LiDAR files to read in
      :param tile_index_file: A file specifying the spatial extents of the LiDAR files.
      :param lidar_classifications_to_keep: A list of LiDAR classifications to keep - '2' for ground, '9' for water.
                                            See https://www.asprs.org/wp-content/uploads/2010/12/LAS_1_4_r13.pdf for
                                            standard list
      :param meta_data: Information to include in the created DEM.


   .. py:method:: add_coarse_dem(coarse_dem)

      Fill gaps in dense DEM from areas with no LiDAR with the coarse DEM.
      Perform linear interpolation.

      Currently doesn't use chunking - this may be required if a large area is covered
      by the coarse DEM.



.. py:class:: RoughnessDem(catchment_geometry, hydrological_dem_path, interpolation_method, elevation_range = None)

   Bases: :py:obj:`LidarBase`

   A class to add a roughness (zo) layer to a hydrologically conditioned DEM.

   They STD and mean height of ground cover classified points are calculated from the
   LiDAR data and z (elevation) layer of the hydrologically conditioned DEM, and used
   to estimate roughness emperically.

   RoughnessDem logic can be controlled by the constructor inputs.

   :param catchment_geometry: Defines the geometry of the catchment
   :param hydrological_dem_path: The path to the hydrologically conditioned DEM.
   :param interpolation_method: If not None, interpolate using that method. Valid options are 'linear',
                                'nearest', and 'cubic'.
   :param lidar_interpolation_method: The interpolation method to apply to LiDAR. Options are: mean, median, IDW.

   .. py:method:: add_lidar(lidar_files, tile_index_file, chunk_size, lidar_classifications_to_keep, source_crs, metadata)

      Read in all LiDAR files and use the point cloud distribution, source_class
      information, and hydrologiaclly conditioned elevations to estimate the roughness
      across the DEM.

      :param source_crs: Coordinate reference system information
      :param chunk_size: The chunk size in pixels for parallel/staged processing
      :param lidar_files: The list of LiDAR files to read in
      :param tile_index_file: A file specifying the spatial extents of the LiDAR files.
      :param lidar_classifications_to_keep: A list of LiDAR classifications to keep - '2' for ground, '9' for water.
                                            See https://www.asprs.org/wp-content/uploads/2010/12/LAS_1_4_r13.pdf for
                                            standard list
      :param meta_data: Information to include in the created DEM.



.. py:function:: read_file_with_pdal(lidar_file, region_to_tile, catchment_geometry, source_crs = None, get_extents = False)

   Read a tile file in using PDAL


.. py:function:: roughness_from_points(point_cloud, xy_out, xy_ground, options, eps = 0, leaf_size = 10)

   Calculate DEM elevation values at the specified locations using the selected
   approach. Options include: mean, median, and inverse distance weighing (IDW). This
   implementation is based on the scipy.spatial.KDTree


.. py:function:: elevation_from_points(point_cloud, xy_out, options, eps = 0, leaf_size = 10)

   Calculate DEM elevation values at the specified locations using the selected
   approach. Options include: mean, median, and inverse distance weighing (IDW). This
   implementation is based on the scipy.spatial.KDTree


.. py:function:: calculate_idw(near_indices, point, tree, point_cloud, smoothing = 0, power = 2)

   Calculate the IDW mean of the 'near_indices' points. This implementation is based
   on the scipy.spatial.KDTree


.. py:function:: calculate_linear(near_indices, point, tree, point_cloud)

   Calculate linear interpolation of the 'near_indices' points. Take the straight
   mean if the points are co-linear or too few for linear interpolation.


.. py:function:: load_tiles_in_chunk(dim_x, dim_y, tile_index_extents, tile_index_name_column, lidar_files, source_crs, chunk_region_to_tile, catchment_geometry)

   Read in all LiDAR files within the chunked region - clipped to within the region
   within which to rasterise.


.. py:function:: roughness_over_chunk(dim_x, dim_y, tile_points, xy_ground, options)

   Rasterise all points within a chunk.


.. py:function:: elevation_over_chunk(dim_x, dim_y, tile_points, options)

   Rasterise all points within a chunk.


.. py:data:: delayed_roughness_over_chunk
   

   Wrap the `rasterise_chunk` routine in dask.delayed

.. py:data:: delayed_elevation_over_chunk
   

   Wrap the `load_tiles_in_chunk` routine in dask.delayed

