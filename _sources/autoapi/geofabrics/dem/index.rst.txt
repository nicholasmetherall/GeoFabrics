:py:mod:`geofabrics.dem`
========================

.. py:module:: geofabrics.dem

.. autoapi-nested-parse::

   This module contains classes associated with loading, generating, and combining
   DEMs.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   geofabrics.dem.ReferenceDem
   geofabrics.dem.DenseDem
   geofabrics.dem.DenseDemFromFiles
   geofabrics.dem.DenseDemFromTiles



Functions
~~~~~~~~~

.. autoapisummary::

   geofabrics.dem.read_file_with_pdal
   geofabrics.dem.rasterise_points
   geofabrics.dem.calculate_idw
   geofabrics.dem.load_tiles_in_chunk
   geofabrics.dem.rasterise_chunk



Attributes
~~~~~~~~~~

.. autoapisummary::

   geofabrics.dem.delayed_rasterise_chunk


.. py:class:: ReferenceDem(dem_file, catchment_geometry, set_foreshore = True, exclusion_extent = None)

   A class to manage reference or background DEMs in the catchment context

   Specifically, clip within the catchment land and foreshore. There is the option to clip outside any LiDAR using the
   optional 'exclusion_extent' input.

   If set_foreshore is True all positive DEM values in the foreshore are set to zero.

   .. py:method:: __del__(self)

      Ensure the memory associated with netCDF files is properly freed.


   .. py:method:: points(self)
      :property:

      The reference DEM points after any extent or foreshore value
      filtering.


   .. py:method:: extents(self)
      :property:

      The extents for the reference DEM



.. py:class:: DenseDem(catchment_geometry, extents, dense_dem, interpolation_method)

   Bases: :py:obj:`abc.ABC`

   An abstract class to manage the dense DEM in a catchment context.

   The dense DEM is made up of a dense DEM that is loaded in, and an offshore DEM that is interpolated from bathymetry
   contours offshore and outside all LiDAR tiles.

   :param catchment_geometry: Defines the spatial extents of the catchment, land, foreshore, and offshore regions
   :param extents: Defines the extents of any dense (LiDAR or refernence DEM) values already added.
   :param dense_dem: The dense portion of the DEM
   :param interpolation_method: If not None, interpolate using that method. Valid options are 'linear', 'nearest', and 'cubic'

   .. py:method:: __del__(self)

      Ensure the memory associated with netCDF files is properly freed.


   .. py:method:: extents(self)
      :property:

      The combined extents for all added LiDAR tiles


   .. py:method:: dense_dem(self)
      :property:

      Return the dense DEM from tiles and any interpolated offshore values


   .. py:method:: dem(self)
      :property:

      Return the combined DEM from tiles and any interpolated offshore values


   .. py:method:: combine_dem_parts(self)

      Return the combined DEM from tiles and any interpolated offshore values


   .. py:method:: interpolate_offshore(self, bathy_contours)

      Performs interpolation offshore outside LiDAR extents using the SciPy RBF function.


   .. py:method:: interpolate_river_bathymetry(self, river_bathymetry)

      Performs interpolation with a river polygon using the SciPy RBF function.



.. py:class:: DenseDemFromFiles(catchment_geometry, dense_dem_path, extents_path, interpolation_method)

   Bases: :py:obj:`DenseDem`

   A class to manage loading in an already created and saved dense DEM that has yet to have an offshore DEM
   associated with it.

   :param Logic controlling behaviour:
                                       interpolation_method
                                           If not None, interpolate using that method. Valid options are 'linear', 'nearest', and 'cubic'


.. py:class:: DenseDemFromTiles(catchment_geometry, interpolation_method, lidar_interpolation_method, drop_offshore_lidar = True, elevation_range = None)

   Bases: :py:obj:`DenseDem`

   A class to manage the population of the DenseDem's dense_dem from LiDAR tiles, and/or a reference DEM.

   The dense DEM is made up of tiles created from dense point data - Either LiDAR point clouds, or a reference DEM.

   DenseDemFromTiles logic can be controlled by the constructor inputs.

   :param drop_offshore_lidar: If True only keep LiDAR values within the foreshore and land regions defined by the catchment_geometry.
                               If False keep all LiDAR values.
   :param interpolation_method: If not None, interpolate using that method. Valid options are 'linear', 'nearest', and 'cubic'.
   :param lidar_interpolation_method: The interpolation method to apply to point clouds. Options are: mean, median, IDW

   .. py:method:: add_lidar(self, lidar_files, tile_index_file, chunk_size, lidar_classifications_to_keep, source_crs, drop_offshore_lidar, metadata)

      Read in all LiDAR files and use to create a dense DEM.

      :param source_crs: Specify if the CRS encoded in the LiDAR files are incorrect/only partially defined
                         (i.e. missing vertical CRS) and need to be overwritten.
      :param drop_offshore_lidar: If True, trim any LiDAR values that are offshore as specified by the catchment_geometry
      :param lidar_classifications_to_keep: A list of LiDAR classifications to keep - '2' for ground, '9' for water. See
                                            https://www.asprs.org/wp-content/uploads/2010/12/LAS_1_4_r13.pdf for standard list
      :param tile_index_file: Must exist if there are many LiDAR files. This is used to determine chunking.


   .. py:method:: add_reference_dem(self, tile_points, tile_extent)

      Update gaps in dense DEM from areas with no LiDAR with the reference DEM.



.. py:function:: read_file_with_pdal(lidar_file, region_to_tile, catchment_geometry, source_crs = None, get_extents = False)

   Read a tile file in using PDAL


.. py:function:: rasterise_points(point_cloud, xy_out, options, eps = 0, leaf_size = 10)

   Calculate DEM elevation values at the specified locations using the selected approach. Options include: mean,
   median, and inverse distance weighing (IDW). This implementation is based on the scipy.spatial.KDTree


.. py:function:: calculate_idw(near_indicies, point, tree, point_cloud, smoothing = 0, power = 2)

   Calculate DEM elevation values at the specified locations by
   calculating the mean. This implementation is based on the
   scipy.spatial.KDTree


.. py:function:: load_tiles_in_chunk(dim_x, dim_y, tile_index_extents, tile_index_name_column, lidar_files, source_crs, chunk_region_to_tile, catchment_geometry)

   Read in all LiDAR files within the chunked region - clipped to within the region within which to rasterise.


.. py:function:: rasterise_chunk(dim_x, dim_y, tile_points, options)

   Rasterise all points within a chunk.


.. py:data:: delayed_rasterise_chunk
   

   Wrap the `load_tiles_in_chunk` routine in dask.delayed

